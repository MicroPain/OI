### 一些量：

**m**为总人数

**sum**为所需的最小船只数

**o**为每只船的限重

数组**P**存放每个人的重量

**i**,**j** 两个指针

分别指当前考虑的最轻和最重者的位置

### 贪心算法：

*1.*从小到大将表示每个人重量的数组P排序。

*2*.选取最轻者 **i** ，再用指针 **j** 从后往前遍历数组，使得 **P[i]**+**P[j]** <=船的限重**o**（此时已成功选出 “一对”）。

*3.*所需总船只数**sum**自增1，指针 **j** 前移一位（因为接下来要考虑的   “最轻者”比第一个“最轻者”重，所能配对的“最重者”就比第一个“最重者”轻，所以之后符合条件的 **j** 一定在前面）。

*4.*指针 **i** 后移一位，重复2,3,4，**直至 i==j**  (i==j就表示同一个人，不能考虑)。

注：4. 结束后，sum的值即为所有“双人船”的数量。但我们还需要考虑那些无人配对的人，他们需要坐“单人船”。

*5.*将sum赋值为当前的sum与总人数减二倍“双人船”数之和

即：

```
sum+=m-2*sum;
```

**m**-2***sum**即为“单人船”数。



------

### 本题的重点：

### 一.   适用贪心的证明：

1.证明思想：反证法

2.证明过程：见《算法竞赛入门经典（第二版）》*[p232]()*.....

------

代码如下：

```c++
#include<iostream>
using namespace std;
int m_sort(int P[],int a,int b) {
	for(int i=a;i<=b;i++) {
		for(int j=i;j<=b;j++) {
			if(P[j]<P[i]) {
				int t=P[j];
				P[j]=P[i];
				P[i]=t;
			}
		}
	}
	return 0;
}
int main() {
	int m,o,sum=0;  //m个人，船的限重为o，共需sum只船 
	cin>>o>>m;
	int P[m+1];
	for(int i=1;i<=m;i++) {
		cin>>P[i];		
	}
	m_sort(P,1,m);
	int j=m;
	for(int i=1;i<j;i++) {		//算出坐两个人的船 
		while(P[j]+P[i]>o&&i<j) {
			j--;
		}
		if(i<j) {
			sum++;
			j--;
		}
	}
	sum+=(m-sum*2); 
	cout<<sum;
	return 0;
}
```

